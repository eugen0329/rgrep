#!/usr/bin/env ruby

require 'pry' 
require 'colorize' 
require 'optparse' 

USAGE = "Usage: rgrep [OPTIONS] PATTERN [FILE]"

def parse_options(args)
  options = {}
  options[:a] = 0
  options[:fnames] = []

  parser = OptionParser.new do |opts|
    opts.banner = USAGE
    opts.on("-a NLINES", OptionParser::DecimalInteger, "Disp NLINES before and after the mutching string") do |arg|
      options[:a] = arg
    end
    opts.on("-f","--files fn1,fn2,fn3", Array, "Set a list of files separated by commas") do |arg|
      options[:fnames].concat( arg )
    end
    opts.on("-g","--regular-expression REGEXP", "Regular expression for searching in file") do |arg|
      options[:regexp] = Regexp.new(arg)
    end
    opts.on("-R","--recursively", "Recursively search from the setted dir") do |arg|
      options[:fnames].concat( Dir['**/*'].reject { |fname| File.directory?(fname) } )
    end
  end
  parser.parse!(args)
  options 
end
  
def find_in_file(file, exp, radius)
  lines = file.map { |a| a }
  lines.select { |it| it =~ exp }.each_with_index do |line,count|
    puts "#{count + 1}) >>>>>>".green
    index = lines.find_index(line)
    puts lines[index - radius, 2 * radius + 1]
  end
end

options = parse_options(ARGV)
exp =   options.has_key?(:regexp) ? options[:regexp] : 
                    ! ARGV.empty? ? Regexp.new(ARGV.shift) : (puts USAGE; exit 1)
options[:fnames].concat(ARGV)

if ! options[:fnames].empty? 
  options[:fnames].each do |fname| 
    File.open(fname) do |file|
      puts "In the file #{fname}:".blue
      find_in_file(file, exp,options[:a])
    end
  end
else
  find_in_file(STDIN.read.chomp.split("\n"), exp, options[:a])
end
